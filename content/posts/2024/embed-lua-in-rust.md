---
title: "Embedding Lua in sqleibniz with Rust"
date: 2024-12-16T11:12:45+01:00
summary: "Improving the SQL DX one blog article at a time"
draft: true
tags:
  - rust
  - sqleibniz
  - lua
---

> I am currently writing a analysis tool for Sql:
> [`sqleibniz`](https://github.com/xnacly/sqleibniz), specifically for the
> sqlite dialect.
>
> The goal is to perform static analysis for sql input, including: syntax
> checks, checks if tables, columns and functions exist. Combining this with an
> embedded sqlite runtime and the ability to assert conditions in this runtime,
> creates a really great dev experience for sql.
>
> Furthermore, I want to be able to show the user high quality error messages
> with context, explainations and the ability to mute certain diagnostics.
>
> After completing the static analysis part of the project, I plan on writing a
> lsp server for sql, so stay tuned for that.

## Lua as scriptable configuration & extending sqleibniz with hooks

I want to get the most out of sqleibniz, for me this includes the ability for
configuration while providing sensible defaults.

Before the changes layed out in this post, sqleibniz was configured via a
`leibniz.toml` file:

```toml
# this is an example file, consult: https://toml.io/en/ for syntax help and
# src/rules.rs::Config for all available options
[disabled]
    # see sqleibniz --help for all available rules
    rules = [
        # by default, sqleibniz specific errors are disabled:
        "NoContent", # source file is empty
        "NoStatements", # source file contains no statements
        "Unimplemented", # construct is not implemented yet
        "BadSqleibnizInstruction", # source file contains a bad sqleibniz instruction

        # ignoring sqlite specific diagnostics:
        # "UnknownKeyword", # an unknown keyword was encountered
        # "UnterminatedString", # a not closed string was found
        # "UnknownCharacter", # an unknown character was found
        # "InvalidNumericLiteral", # an invalid numeric literal was found
        # "InvalidBlob", # an invalid blob literal was found (either bad hex data or incorrect syntax)
        # "Syntax", # a structure with incorrect syntax was found
        # "Semicolon", # a semicolon is missing
    ]
```

{{<callout type="Tip">}}
A `rule` refers to a group of diagnostics, as their comments document.
Sqleibniz groups diagnostics according to these rules. This enables omitting a
singular or multiple diagnostics, alternatively to the configuration file,
sqleibniz accepts the `-D` (short for disable) cli flag, followed the be rule
to disable (the list of available rules can be found with `sqleibniz --help`).
For instance, disabling all non sqlite diagnostics:

```text
$ sqleibniz \
    -Dno-statements \
    -Dno-content \
    -Dunimplemented \
    -Dbad-sqleibniz-instruction
```

Sqleibniz prints the rules it currently ignores:

```text
$ sqleibniz \
    -Dno-statements \
    -Dno-content \
    -Dunimplemented \
    -Dbad-sqleibniz-instruction
warn: Ignoring the following diagnostics, as specified:
 -> NoStatements
 -> NoContent
 -> Unimplemented
 -> BadSqleibnizInstruction
```

{{</callout>}}

Why switch from toml to lua when cleary toml already allows us to have all the
configuration we need? The answer is scripting. I want to enable users to write
their own plugins/addons/hooks for whatever usecase anyone could have.

My idea is to provide an array of hooks in lua, each one with a name, a node
type to run the callback for and a callback that, once run, gets the context of
the node. Node refers to an element in the abstract syntax tree generated by
sqleibniz. `leibniz.lua` already contains the configuration from before,
extended with two examplary hooks:

````lua
-- this is an example configuration, consult: https://www.lua.org/manual/5.4/
-- or https://learnxinyminutes.com/docs/lua/ for syntax help and
-- src/rules.rs::Config for all available options
leibniz = {
    disabled_rules = {
        -- ignore sqleibniz specific diagnostics:
        "NoContent",               -- source file is empty
        "NoStatements",            -- source file contains no statements
        "Unimplemented",           -- construct is not implemented yet
        "BadSqleibnizInstruction", -- source file contains a bad sqleibniz instruction

        -- ignore sqlite specific diagnostics:

        -- "UnknownKeyword", -- an unknown keyword was encountered
        -- "UnterminatedString", -- a not closed string was found
        -- "UnknownCharacter", -- an unknown character was found
        -- "InvalidNumericLiteral", -- an invalid numeric literal was found
        -- "InvalidBlob", -- an invalid blob literal was found (either bad hex data or incorrect syntax)
        -- "Syntax", -- a structure with incorrect syntax was found
        -- "Semicolon", -- a semicolon is missing
    },
    -- sqleibniz allows for writing custom rules with lua
    hooks = {
        {
            -- summarises the hooks content
            name = "idents should be lowercase",
            -- instructs sqleibniz which node to execute the `hook` for
            node = "literal",
            -- sqleibniz calls the hook function once it encounters a node name
            -- matching the hook.node content
            --
            -- The `node` argument holds the following fields:
            --
            --```
            --    node: {
            --     kind: string,
            --     text: string,
            --     children: node[],
            --    }
            --```
            --
            hook = function(node)
                if node.kind == "ident" then
                    if string.match(node.text, "%u") then
                        -- returing an error passes the diagnostic to sqleibniz,
                        -- thus a pretty message with the name of the hook, the
                        -- node it occurs and the message passed to error() is
                        -- generated
                        error("All idents should be lowercase")
                    end
                end
            end
        },
        {
            name = "idents shouldn't be longer than 12 characters",
            node = "literal",
            hook = function(node)
                local max_size = 12
                if node.kind == "ident" then
                    if string.len(node.text) >= max_size then
                        error("idents shouldn't be longer than " .. max_size .. " characters")
                    end
                end
            end
        }
    }
}
````

Since no one uses sqleibniz yet and I have no semantic versioning in place, I
do not care about breaking backwards compatibility and just made the change,
small projects ROCK!

## Accessing Lua Tables as Rust data structures

## Injecting Lua functions into sqleibniz

## Calling Lua functions from Rust
